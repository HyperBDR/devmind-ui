<template>
  <BaseModal :show="show" :title="modalTitle" @close="handleClose">
    <!-- Fixed Preview Area (Non-scrollable) -->
    <div class="sticky top-0 z-50 bg-white border-b border-gray-200 pb-3 mb-4 -mx-4 -mt-4 px-4 pt-3 shadow-sm">
      <div class="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg p-3 space-y-2">
        <!-- Task Name (最多两行显示) -->
        <div>
          <div class="text-xs text-blue-700 font-medium mb-1">{{ t('scheduledTasks.form.name') }}</div>
          <div class="text-sm text-blue-900 font-mono break-words line-clamp-2">
            {{ autoGeneratedName || formData.name || t('scheduledTasks.form.nameAutoGenerated') }}
          </div>
        </div>
        <!-- Schedule Preview and Start Time (同一行) -->
        <div class="flex items-center gap-4 text-sm">
          <div v-if="schedulePreview" class="flex-1">
            <div class="text-xs text-blue-700 font-medium mb-1">{{ t('scheduledTasks.form.schedulePreview') }}</div>
            <div class="text-sm text-blue-900">{{ schedulePreview }}</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Scrollable Form Content -->
    <form @submit.prevent="handleSubmit" class="space-y-6">
      <!-- Task Type Selection -->
      <div>
        <label class="block text-sm font-medium text-gray-700 mb-2">
          {{ t('scheduledTasks.form.taskType') }}
          <span class="text-red-500">*</span>
        </label>
        <select
          v-model="formData.task_type"
          class="input w-full"
          :class="{ 'border-red-500': errors.task_type }"
          @change="handleTaskTypeChange"
        >
          <option value="">{{ t('scheduledTasks.form.selectTaskType') }}</option>
          <option
            v-for="taskType in availableTaskTypes"
            :key="taskType.value"
            :value="taskType.value"
          >
            {{ taskType.label }}
          </option>
        </select>
        <p v-if="errors.task_type" class="text-sm text-red-600 mt-1">
          {{ errors.task_type }}
        </p>
        <p v-else-if="selectedTaskType" class="text-sm text-gray-500 mt-1">
          {{ selectedTaskType.description }}
        </p>
        <p v-else class="text-sm text-gray-500 mt-1">
          {{ t('scheduledTasks.form.taskTypeHelp') }}
        </p>
      </div>

      <!-- GitHub Trending Configuration -->
      <div v-if="isGithubTrendingTask" class="space-y-4">
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.langCode') }}
            </label>
            <select v-model="formData.kwargs.lang_code" class="input w-full">
              <option value="any">{{ t('scheduledTasks.form.langCodeAny') }}</option>
              <option value="zh">{{ t('scheduledTasks.form.langCodeZh') }}</option>
              <option value="en">{{ t('scheduledTasks.form.langCodeEn') }}</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.lang') }}
            </label>
            <select v-model="formData.kwargs.lang" class="input w-full">
              <option value="any">{{ t('scheduledTasks.form.langAny') }}</option>
              <option value="python">Python</option>
              <option value="javascript">JavaScript</option>
              <option value="java">Java</option>
              <option value="go">Go</option>
              <option value="rust">Rust</option>
              <option value="typescript">TypeScript</option>
              <option value="cpp">C++</option>
              <option value="c">C</option>
              <option value="csharp">C#</option>
              <option value="php">PHP</option>
              <option value="ruby">Ruby</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.trendingPeriod') }}
            </label>
            <select v-model="formData.kwargs.since" class="input w-full">
              <option value="today">{{ t('scheduledTasks.form.trendingPeriodToday') }}</option>
              <option value="weekly">{{ t('scheduledTasks.form.trendingPeriodWeekly') }}</option>
              <option value="monthly">{{ t('scheduledTasks.form.trendingPeriodMonthly') }}</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.maxProjects') }}
            </label>
            <input
              v-model.number="formData.kwargs.num"
              type="number"
              min="1"
              max="100"
              class="input w-full"
            />
            <p class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.maxProjectsHelp') }}
            </p>
          </div>
        </div>
      </div>

      <!-- Keywords or Topics Selection (二选一) -->
      <div v-if="!isGithubTrendingTask" class="space-y-4">
        <!-- Selection Type - Segmented Control Style with Color Accents -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            {{ t('scheduledTasks.form.searchType') }}
            <span class="text-red-500">*</span>
          </label>
          <div class="inline-flex rounded-md bg-gray-100 p-0.5 shadow-sm border border-gray-200" role="group">
            <button
              type="button"
              @click="searchType = 'keywords'; handleSearchTypeChange()"
              class="px-4 py-1.5 text-xs font-medium rounded transition-all duration-200 min-w-[90px] relative"
              :class="
                searchType === 'keywords'
                  ? 'bg-gradient-to-r from-primary-500 to-primary-600 text-white shadow-sm ring-1 ring-primary-300'
                  : 'text-gray-600 hover:text-primary-600 hover:bg-primary-50/50'
              "
            >
              <span class="relative z-10">{{ t('scheduledTasks.form.keywords') }}</span>
            </button>
            <button
              type="button"
              @click="searchType = 'topics'; handleSearchTypeChange()"
              class="px-4 py-1.5 text-xs font-medium rounded transition-all duration-200 min-w-[90px] relative"
              :class="
                searchType === 'topics'
                  ? 'bg-gradient-to-r from-primary-500 to-primary-600 text-white shadow-sm ring-1 ring-primary-300'
                  : 'text-gray-600 hover:text-primary-600 hover:bg-primary-50/50'
              "
            >
              <span class="relative z-10">{{ t('scheduledTasks.form.topics') }}</span>
            </button>
          </div>
        </div>

        <!-- Keywords Input (when searchType is 'keywords') - Dynamic Input Boxes -->
        <div v-if="searchType === 'keywords'">
          <label class="block text-sm font-medium text-gray-700 mb-2">
            {{ t('scheduledTasks.form.keywords') }}
            <span class="text-red-500">*</span>
          </label>
          <div class="space-y-2">
            <!-- Keyword Input Boxes -->
            <div
              v-for="(keyword, index) in keywordInputs"
              :key="index"
              class="flex items-center gap-2"
            >
              <div class="flex-1 relative">
                <input
                  v-model="keywordInputs[index]"
                  type="text"
                  :placeholder="t('scheduledTasks.form.keywordPlaceholder', { num: index + 1 })"
                  class="input w-full pr-16"
                  :class="{
                    'border-red-500': errors[`keyword_${index}`] || (keyword && keyword.length > 20)
                  }"
                  @input="handleKeywordInput(index)"
                  @blur="validateKeyword(index)"
                  maxlength="20"
                />
                <span
                  class="absolute right-3 top-1/2 -translate-y-1/2 text-xs"
                  :class="keyword && keyword.length > 20 ? 'text-red-500' : 'text-gray-400'"
                >
                  {{ keyword ? keyword.length : 0 }}/20
                </span>
              </div>
              <button
                v-if="keywordInputs.length > 1"
                type="button"
                @click="removeKeywordInput(index)"
                class="text-red-500 hover:text-red-700 p-2 rounded-md hover:bg-red-50 transition-colors"
                :title="t('common.delete')"
              >
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <!-- Error Message for Individual Keyword -->
            <template v-for="(keyword, index) in keywordInputs" :key="`error-${index}`">
              <p
                v-if="errors[`keyword_${index}`]"
                class="text-sm text-red-600 -mt-1"
              >
                {{ errors[`keyword_${index}`] }}
              </p>
            </template>
            <!-- Add Button -->
            <button
              v-if="keywordInputs.length < 4"
              type="button"
              @click="addKeywordInput"
              class="w-full py-2 px-3 text-sm text-primary-600 border border-dashed border-primary-300 rounded-md hover:bg-primary-50 hover:border-primary-400 transition-colors flex items-center justify-center gap-2"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
              </svg>
              {{ t('scheduledTasks.form.addKeyword') }}
            </button>
          </div>
          <p class="text-sm text-gray-500 mt-1">
            {{ t('scheduledTasks.form.keywordsHelp') }} ({{ t('scheduledTasks.form.maxKeywords', { count: 4 }) }})
          </p>
          <p v-if="errors.keywords" class="text-sm text-red-600 mt-1">
            {{ errors.keywords }}
          </p>
        </div>

        <!-- Topics Selection (when searchType is 'topics') - Grid Button Style -->
        <div v-if="searchType === 'topics'">
          <label class="block text-sm font-medium text-gray-700 mb-2">
            {{ t('scheduledTasks.form.topics') }}
            <span class="text-red-500">*</span>
          </label>
          <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
            <button
              v-for="topic in availableTopics"
              :key="topic"
              type="button"
              @click="selectedTopic = topic; handleTopicChange()"
              class="px-4 py-2 text-sm font-medium rounded-md border transition-colors text-center"
              :class="
                selectedTopic === topic
                  ? 'bg-primary-50 border-primary-300 text-primary-700'
                  : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'
              "
            >
              {{ topic }}
            </button>
          </div>
          <p v-if="errors.topics" class="text-sm text-red-600 mt-1">
            {{ errors.topics }}
          </p>
        </div>
      </div>

      <!-- Schedule Settings -->
      <div class="bg-gray-50 rounded-lg p-4 space-y-4">
        <h4 class="font-medium text-gray-900 text-sm">
          {{ t('scheduledTasks.form.crontabSettings') }}
        </h4>

        <!-- Minute and Hour in Grid Layout -->
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.minute') }}
              <span class="text-red-500">*</span>
            </label>
            <input
              v-model="crontabInput.minute"
              type="text"
              :placeholder="t('scheduledTasks.form.minutePlaceholder')"
              class="input w-full"
              :class="{ 'border-red-500': errors.minute }"
              @blur="validateCrontab"
            />
            <p v-if="errors.minute" class="text-sm text-red-600 mt-1">
              {{ errors.minute }}
            </p>
            <p v-else-if="formData.task_type === 'articlehub.tasks.monitor.alert_unpublished_articles'" class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.alertTaskMinuteHelp') }}
            </p>
            <p v-else class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.minuteHelp') }}
            </p>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.hour') }}
              <span class="text-red-500">*</span>
            </label>
            <input
              v-model="crontabInput.hour"
              type="text"
              :placeholder="t('scheduledTasks.form.hourPlaceholder')"
              class="input w-full"
              :class="{ 'border-red-500': errors.hour }"
              @blur="validateCrontab"
            />
            <p v-if="errors.hour" class="text-sm text-red-600 mt-1">
              {{ errors.hour }}
            </p>
            <p class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.hourHelp') }}
            </p>
          </div>
        </div>

        <!-- Timezone Info -->
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
          <div class="flex items-center gap-2">
            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <div class="flex-1">
              <p class="text-sm font-medium text-blue-900">
                {{ t('scheduledTasks.form.timezoneInfo') }}
              </p>
              <p class="text-xs text-blue-700 mt-1">
                {{ t('scheduledTasks.form.timezoneDescription', { timezone: currentTimezoneLabel }) }}
              </p>
            </div>
          </div>
        </div>

        <!-- Day of Month, Month, Day of Week (for GitHub trending and other tasks that need weekly/monthly scheduling) -->
        <div v-if="isGithubTrendingTask || formData.task_type === 'articlehub.collect_articles'" class="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.dayOfMonth') }}
            </label>
            <input
              v-model="crontabInput.day_of_month"
              type="text"
              :placeholder="t('scheduledTasks.form.dayOfMonthPlaceholder')"
              class="input w-full"
              :class="{ 'border-red-500': errors.day_of_month }"
              @blur="validateCrontab"
            />
            <p v-if="errors.day_of_month" class="text-sm text-red-600 mt-1">
              {{ errors.day_of_month }}
            </p>
            <p v-else class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.dayOfMonthHelp') }}
            </p>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.monthOfYear') }}
            </label>
            <input
              v-model="crontabInput.month_of_year"
              type="text"
              :placeholder="t('scheduledTasks.form.monthOfYearPlaceholder')"
              class="input w-full"
              :class="{ 'border-red-500': errors.month_of_year }"
              @blur="validateCrontab"
            />
            <p v-if="errors.month_of_year" class="text-sm text-red-600 mt-1">
              {{ errors.month_of_year }}
            </p>
            <p v-else class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.monthOfYearHelp') }}
            </p>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              {{ t('scheduledTasks.form.dayOfWeek') }}
            </label>
            <input
              v-model="crontabInput.day_of_week"
              type="text"
              :placeholder="t('scheduledTasks.form.dayOfWeekPlaceholder')"
              class="input w-full"
              :class="{ 'border-red-500': errors.day_of_week }"
              @blur="validateCrontab"
            />
            <p v-if="errors.day_of_week" class="text-sm text-red-600 mt-1">
              {{ errors.day_of_week }}
            </p>
            <p v-else class="text-sm text-gray-500 mt-1">
              {{ t('scheduledTasks.form.dayOfWeekHelp') }}
            </p>
          </div>
        </div>
      </div>

      <!-- Other Options -->
      <div v-if="!isGithubTrendingTask" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <BaseInput
          v-model.number="formData.kwargs.count"
          type="number"
          :label="t('scheduledTasks.form.count')"
          min="1"
        />

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            {{ t('scheduledTasks.form.period') }}
          </label>
          <select v-model="formData.kwargs.period" class="input w-full">
            <option value="1d">1d - 1 Day</option>
            <option value="7d">7d - 7 Days</option>
            <option value="30d">30d - 30 Days</option>
          </select>
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            {{ t('scheduledTasks.form.sourceLanguage') }}
          </label>
          <select
            v-model="formData.kwargs.source_language"
            class="input w-full"
          >
            <option value="en">en - English</option>
            <option value="zh">zh - Chinese</option>
            <option value="fr">fr - French</option>
            <option value="de">de - German</option>
            <option value="ja">ja - Japanese</option>
            <option value="ko">ko - Korean</option>
          </select>
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            {{ t('scheduledTasks.form.sourceRegion') }}
          </label>
          <select
            v-model="formData.kwargs.source_region"
            class="input w-full"
          >
            <option value="US">US - United States</option>
            <option value="CN">CN - China Mainland</option>
            <option value="GB">GB - United Kingdom</option>
            <option value="CA">CA - Canada</option>
            <option value="AU">AU - Australia</option>
            <option value="SG">SG - Singapore</option>
            <option value="JP">JP - Japan</option>
            <option value="KR">KR - Korea</option>
          </select>
        </div>
      </div>

      <!-- Social Account -->
      <div>
        <label class="block text-sm font-medium text-gray-700 mb-2">
          {{ t('scheduledTasks.form.socialAccount') }}
          <span class="text-red-500">*</span>
        </label>
          <input
            v-model="formData.kwargs.social_account"
            type="text"
            :placeholder="t('scheduledTasks.form.socialAccountPlaceholder')"
            class="input w-full"
            required
          />
        <p class="text-sm text-gray-500 mt-1">
          {{ t('scheduledTasks.form.socialAccountHelp') }}
        </p>
        <p v-if="errors.social_account" class="text-sm text-red-600 mt-1">
          {{ errors.social_account }}
        </p>
      </div>

      <!-- Transform Formats Selection -->
      <div class="p-4 bg-white rounded-lg border border-gray-200">
        <label class="block text-sm font-medium text-gray-700 mb-2">
          {{ t('scheduledTasks.form.transformFormats') }}
        </label>
        <div class="space-y-3">
          <label class="flex items-start">
            <input
              type="checkbox"
              value="markdown_json"
              v-model="formData.kwargs.transform_formats"
              class="checkbox mr-2 mt-0.5 flex-shrink-0"
            />
            <span class="text-sm text-gray-700 leading-relaxed">
              {{ t('scheduledTasks.form.markdownJson') }}
            </span>
          </label>
          <label class="flex items-start">
            <input
              type="checkbox"
              value="toutiao"
              v-model="formData.kwargs.transform_formats"
              class="checkbox mr-2 mt-0.5 flex-shrink-0"
            />
            <span class="text-sm text-gray-700 leading-relaxed">
              {{ t('scheduledTasks.form.toutiao') }}
            </span>
          </label>
          <label class="flex items-start">
            <input
              type="checkbox"
              value="wechat_html"
              v-model="formData.kwargs.transform_formats"
              class="checkbox mr-2 mt-0.5 flex-shrink-0"
            />
            <span class="text-sm text-gray-700 leading-relaxed">
              {{ t('scheduledTasks.form.wechatHtml') }}
            </span>
          </label>
          <label class="flex items-start">
            <input
              type="checkbox"
              value="douyin_markdown"
              v-model="formData.kwargs.transform_formats"
              class="checkbox mr-2 mt-0.5 flex-shrink-0"
            />
            <span class="text-sm text-gray-700 leading-relaxed">
              {{ t('scheduledTasks.form.douyinMarkdownJson') }}
            </span>
          </label>
        </div>
        <p class="text-xs text-gray-500 mt-2">
          {{ t('scheduledTasks.form.transformFormatsHelp') }}
        </p>
        <p v-if="errors.transform_formats" class="text-sm text-red-600 mt-1">
          {{ errors.transform_formats }}
        </p>
      </div>

      <!-- Enabled Toggle -->
      <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
        <div>
          <label class="block text-sm font-medium text-gray-700">
            {{ t('scheduledTasks.form.enabled') }}
          </label>
          <p class="text-sm text-gray-500 mt-1">
            {{ t('scheduledTasks.form.enabledHelp') }}
          </p>
        </div>
        <label class="relative inline-flex items-center cursor-pointer">
          <input
            type="checkbox"
            v-model="formData.enabled"
            class="sr-only peer"
          />
          <div
            class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-primary-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"
          ></div>
        </label>
      </div>
    </form>

    <template #footer>
      <div class="flex flex-col-reverse sm:flex-row justify-end gap-2">
        <BaseButton variant="secondary" @click="handleClose" class="w-full sm:w-auto">
          {{ t('common.cancel') }}
        </BaseButton>
        <BaseButton @click="handleSubmit" :loading="saving" class="w-full sm:w-auto">
          {{ t('common.save') }}
        </BaseButton>
      </div>
    </template>
  </BaseModal>
</template>

<script setup>
import { ref, computed, watch, onMounted } from 'vue'
import { useI18n } from 'vue-i18n'
import BaseModal from '@/components/ui/BaseModal.vue'
import BaseInput from '@/components/ui/BaseInput.vue'
import BaseButton from '@/components/ui/BaseButton.vue'
import { format } from 'date-fns'
import { scheduledTasksApi } from '@/api/scheduledTasks'
import { extractResponseData } from '@/utils/api'
import { useUserStore } from '@/store/user'
import { usePreferencesStore } from '@/store/preferences'
import { detectTimezone } from '@/utils/timezone'
import { getTimezoneLabel } from '@/utils/timezones'

const props = defineProps({
  show: {
    type: Boolean,
    default: false
  },
  task: {
    type: Object,
    default: null
  }
})

const emit = defineEmits(['close', 'save', 'save-error'])

const { t } = useI18n()

const TASK_TYPE = 'articlehub.collect_articles'
const availableTaskTypes = ref([])
const loadingTaskTypes = ref(false)

const availableTopics = [
  'WORLD',
  'NATION',
  'BUSINESS',
  'TECHNOLOGY',
  'ENTERTAINMENT',
  'SPORTS',
  'SCIENCE',
  'HEALTH'
]

const saving = ref(false)
const errors = ref({})
const selectedTopic = ref('')
const searchType = ref('keywords') // 'keywords' or 'topics'
const keywordInputs = ref(['']) // Array of keyword input values

// Get current time as default start time
const getCurrentDateTime = () => {
  const now = new Date()
  const year = now.getFullYear()
  const month = String(now.getMonth() + 1).padStart(2, '0')
  const day = String(now.getDate()).padStart(2, '0')
  const hours = String(now.getHours()).padStart(2, '0')
  const minutes = String(now.getMinutes()).padStart(2, '0')
  return `${year}-${month}-${day}T${hours}:${minutes}`
}

const DEFAULT_FORM_DATA = {
  name: '',
  task_type: TASK_TYPE,
  schedule_type: 'crontab',
  schedule_value: {
    minute: String(new Date().getMinutes()),
    hour: '*'
  },
  start_time: getCurrentDateTime(),
  kwargs: {
    keywords: [],
    topics: [],
    count: 10,
    source_language: 'en',
    source_region: 'US',
    period: '7d',
    social_account: '',
    transform_formats: ['markdown_json', 'toutiao'],
    lang_code: 'any',
    lang: 'any',
    since: 'today',
    num: 20
  },
  enabled: true
}

const crontabInput = ref({
  minute: String(new Date().getMinutes()),
  hour: '*',
  day_of_month: '*',
  month_of_year: '*',
  day_of_week: '*'
})

const formData = ref({ ...DEFAULT_FORM_DATA })
const keywordsInput = ref('')
const topicsInput = ref('')
const preferencesStore = usePreferencesStore()

const isAlertTask = computed(() => {
  return formData.value.task_type === 'articlehub.tasks.monitor.alert_unpublished_articles'
})

const isGithubTrendingTask = computed(() => {
  return formData.value.task_type === 'github_trending.collect_github_trendings'
})

// Get current timezone from preferences store or detect from browser
const currentTimezone = computed(() => {
  return preferencesStore.currentTimezone || detectTimezone()
})

// Get timezone label for display
const currentTimezoneLabel = computed(() => {
  const tz = currentTimezone.value
  try {
    return getTimezoneLabel(tz)
  } catch {
    return tz
  }
})

const modalTitle = computed(() => {
  return props.task
    ? t('scheduledTasks.editTask')
    : t('scheduledTasks.createTask')
})

const schedulePreview = computed(() => {
  const minute = crontabInput.value.minute || '*'
  const hour = crontabInput.value.hour || '*'
  const dayOfMonth = crontabInput.value.day_of_month || '*'
  const monthOfYear = crontabInput.value.month_of_year || '*'
  const dayOfWeek = crontabInput.value.day_of_week || '*'

  return formatCrontabPreview(minute, hour, dayOfMonth, monthOfYear, dayOfWeek)
})

// Helper function to format crontab preview
const formatCrontabPreview = (minute, hour, dayOfMonth, monthOfYear, dayOfWeek) => {
  const formatHour = (h) => {
    if (h === '*') {
      return t('scheduledTasks.form.previewEveryHour', { minute })
    }
    if (typeof h === 'string') {
      const hours = h.split(',').map(h => h.trim()).filter(h => h)
      if (hours.length === 0) return '-'
      if (hours.length === 24) {
        return t('scheduledTasks.form.previewEveryHour', { minute })
      }
      if (hours.length <= 5) {
        const hourDisplay = hours.map(h => String(h).padStart(2, '0')).join(', ')
        return t('scheduledTasks.form.previewSchedule', {
          minute,
          hours: hourDisplay
        })
      }
      const hourDisplay = t('scheduledTasks.form.multipleHours', { count: hours.length })
      return t('scheduledTasks.form.previewSchedule', {
        minute,
        hours: hourDisplay
      })
    }
    return t('scheduledTasks.form.previewSchedule', {
      minute,
      hours: String(h).padStart(2, '0')
    })
  }

  // If only hour and minute are set (default case), use simple format
  if (dayOfMonth === '*' && monthOfYear === '*' && dayOfWeek === '*') {
    return formatHour(hour)
  }

  // Build detailed preview for complex schedules
  const parts = []

  if (monthOfYear !== '*') {
    const months = monthOfYear.split(',').map(m => m.trim()).filter(m => m)
    if (months.length === 1) {
      parts.push(months[0] + t('scheduledTasks.form.monthUnit'))
    } else if (months.length <= 3) {
      parts.push(months.join(',') + t('scheduledTasks.form.monthUnit'))
    } else {
      parts.push(t('scheduledTasks.form.multipleMonths', { count: months.length }))
    }
  }

  if (dayOfMonth !== '*') {
    const days = dayOfMonth.split(',').map(d => d.trim()).filter(d => d)
    if (days.length === 1) {
      parts.push(days[0] + t('scheduledTasks.form.dayUnit'))
    } else if (days.length <= 3) {
      parts.push(days.join(',') + t('scheduledTasks.form.dayUnit'))
    } else {
      parts.push(t('scheduledTasks.form.multipleDays', { count: days.length }))
    }
  }

  if (dayOfWeek !== '*') {
    const dayNames = t('scheduledTasks.form.dayOfWeekNames').split(',')
    const days = dayOfWeek.split(',').map(d => {
      const dayNum = parseInt(d.trim())
      if (dayNum === 0 || dayNum === 7) return dayNames[0]
      if (dayNum >= 1 && dayNum <= 6) return dayNames[dayNum]
      return d
    })
    parts.push(days.join(','))
  }

  // Add time part
  let hourStr = ''
  if (hour === '*') {
    hourStr = t('scheduledTasks.form.everyHour')
  } else if (typeof hour === 'string') {
    const hours = hour.split(',').map(h => String(h.trim()).padStart(2, '0'))
    hourStr = hours.join(',') + t('scheduledTasks.form.hourUnit')
  } else {
    hourStr = String(hour).padStart(2, '0') + t('scheduledTasks.form.hourUnit')
  }
  parts.push(hourStr)
  parts.push(minute + t('scheduledTasks.form.minuteUnit'))

  return parts.join(' ') + t('scheduledTasks.form.execute')
}

const minStartTime = computed(() => {
  return getCurrentDateTime()
})

// Format datetime for input field (convert UTC to local)
const formatDateTimeForInput = (dateString) => {
  if (!dateString) return getCurrentDateTime()
  try {
    const date = new Date(dateString)
    if (isNaN(date.getTime())) return getCurrentDateTime()
    // Convert UTC to local time for input field
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    const hours = String(date.getHours()).padStart(2, '0')
    const minutes = String(date.getMinutes()).padStart(2, '0')
    return `${year}-${month}-${day}T${hours}:${minutes}`
  } catch {
    return getCurrentDateTime()
  }
}

// Format display time
const formatDisplayTime = (dateString) => {
  if (!dateString) return t('scheduledTasks.form.startTimeNow')
  try {
    return format(new Date(dateString), 'yyyy-MM-dd HH:mm')
  } catch {
    return dateString
  }
}

// Get selected task type info
const selectedTaskType = computed(() => {
  return availableTaskTypes.value.find(
    type => type.value === formData.value.task_type
  )
})

// Load available task types from API
const loadTaskTypes = async () => {
  loadingTaskTypes.value = true
  try {
    const response = await scheduledTasksApi.getTaskTypes()
    const data = extractResponseData(response)
    availableTaskTypes.value = Array.isArray(data) ? data : []

    // Set default task type if not set and types are loaded
    if (!formData.value.task_type && availableTaskTypes.value.length > 0) {
      formData.value.task_type = availableTaskTypes.value[0].value
    }
  } catch (error) {
    console.error('Failed to load task types:', error)
    // Fallback to default task type
    availableTaskTypes.value = [{
      value: TASK_TYPE,
      label: 'Google News Collection',
      description: 'Collect articles from Google News based on keywords or topics'
    }]
    if (!formData.value.task_type) {
      formData.value.task_type = TASK_TYPE
    }
  } finally {
    loadingTaskTypes.value = false
  }
}

const handleTaskTypeChange = () => {
  // Ensure collection fields are initialized
  if (!formData.value.kwargs.keywords) {
    formData.value.kwargs.keywords = []
  }
  if (!formData.value.kwargs.topics) {
    formData.value.kwargs.topics = []
  }
  if (!formData.value.kwargs.social_account) {
    formData.value.kwargs.social_account = ''
  }
  if (!formData.value.kwargs.transform_formats) {
    formData.value.kwargs.transform_formats = ['markdown_json', 'toutiao']
  }
  // Initialize GitHub trending fields if needed
  if (formData.value.task_type === 'github_trending.collect_github_trendings') {
    if (!formData.value.kwargs.lang_code) {
      formData.value.kwargs.lang_code = 'any'
    }
    if (!formData.value.kwargs.lang) {
      formData.value.kwargs.lang = 'any'
    }
    if (!formData.value.kwargs.since) {
      formData.value.kwargs.since = 'today'
    }
    if (formData.value.kwargs.num === undefined) {
      formData.value.kwargs.num = 20
    }
  }
  generateTaskName()
}

// Auto-generate task name based on selected parameters
// Format: 任务类型显示名称_关键字_主题_社交媒体账号_时间戳
const autoGeneratedName = computed(() => {
  const parts = []

  // Add task type display name as prefix (use selected task type's label)
  if (selectedTaskType.value?.label) {
    // Remove spaces from label and use as prefix
    const taskTypeName = selectedTaskType.value.label.replace(/\s+/g, '')
    parts.push(taskTypeName)
  } else if (formData.value.task_type) {
    // Fallback: use task type value if no label available
    const taskTypeName = formData.value.task_type.split('.').pop()?.replace(/_/g, '') || 'Task'
    parts.push(taskTypeName)
  }

  // For GitHub trending tasks, add trending parameters
  if (formData.value.task_type === 'github_trending.collect_github_trendings') {
    if (formData.value.kwargs.since) {
      parts.push(formData.value.kwargs.since)
    }
    if (formData.value.kwargs.lang && formData.value.kwargs.lang !== 'any') {
      parts.push(formData.value.kwargs.lang)
    }
    if (formData.value.kwargs.lang_code && formData.value.kwargs.lang_code !== 'any') {
      parts.push(formData.value.kwargs.lang_code)
    }
  } else {
    // Add keywords (max 4, but only show first 3 in name for brevity)
    const keywords = keywordInputs.value
      .map(k => k.trim())
      .filter(k => k)
      .slice(0, 3)

    if (keywords.length > 0) {
      parts.push(keywords.join('_'))
    } else if (formData.value.kwargs.keywords && formData.value.kwargs.keywords.length > 0) {
      const fallbackKeywords = formData.value.kwargs.keywords.slice(0, 3).join('_')
      parts.push(fallbackKeywords)
    }

    // Add topic (single selection)
    if (formData.value.kwargs.topics && formData.value.kwargs.topics.length > 0) {
      const topic = formData.value.kwargs.topics[0]
      parts.push(topic)
    }

    // Add social account
    if (formData.value.kwargs.social_account && formData.value.kwargs.social_account.trim()) {
      parts.push(formData.value.kwargs.social_account.trim())
    }
  }

  // Add timestamp to prevent duplicates (only if we have other parts)
  // Format: MMddYYHHmmss (月月日日年年分分时时秒秒)
  if (parts.length > 0) {
    const now = new Date()
    const month = String(now.getMonth() + 1).padStart(2, '0')
    const day = String(now.getDate()).padStart(2, '0')
    const year = String(now.getFullYear()).slice(-2)
    const hours = String(now.getHours()).padStart(2, '0')
    const minutes = String(now.getMinutes()).padStart(2, '0')
    const seconds = String(now.getSeconds()).padStart(2, '0')
    const timestamp = `${month}${day}${year}${hours}${minutes}${seconds}`
    parts.push(timestamp)
  }

  return parts.length > 0 ? parts.join('_') : ''
})

const generateTaskName = () => {
  if (!props.task) {
    // Use autoGeneratedName computed value directly
    // It already includes task type display name, keywords, topics, social account, and timestamp
    if (autoGeneratedName.value) {
      formData.value.name = autoGeneratedName.value
      previousAutoName.value = autoGeneratedName.value
    }
  }
}

const validateCrontab = () => {
  delete errors.value.minute
  delete errors.value.hour

  const taskType = formData.value.task_type
  const isAlertTask = taskType === 'articlehub.tasks.monitor.alert_unpublished_articles'

  // Validate minute
  const minute = crontabInput.value.minute.trim()
  if (!minute) {
    errors.value.minute = t('scheduledTasks.form.minuteRequired')
    return false
  }

    if (isAlertTask) {
      // For alert tasks, minute must be a single number (0-59)
      const minutePattern = /^(\d+)$/
      const minuteNum = parseInt(minute)
      if (!minutePattern.test(minute) || isNaN(minuteNum) || minuteNum < 0 || minuteNum > 59) {
        errors.value.minute = t('scheduledTasks.form.alertTaskMinuteInvalid')
        return false
      }
  } else {
    // For other tasks, allow standard crontab format
    if (minute !== '*') {
      const minuteValues = minute.split(',').map(m => m.trim())
      for (const m of minuteValues) {
        const num = parseInt(m)
        if (isNaN(num) || num < 0 || num > 59) {
          errors.value.minute = t('scheduledTasks.form.minuteInvalid')
          return false
        }
      }
    }
  }

  // Validate hour
  const hour = crontabInput.value.hour.trim()
  if (!hour) {
    errors.value.hour = t('scheduledTasks.form.hourRequired')
    return false
  }

    if (isAlertTask) {
      // For alert tasks, hour must be */1 or * (every hour)
      const hourPattern = /^(\*\/1|\*)$/
      if (!hourPattern.test(hour)) {
        errors.value.hour = t('scheduledTasks.form.alertTaskHourInvalid')
        return false
      }
  } else {
    // For other tasks, allow standard crontab format
    if (hour !== '*') {
      const hourValues = hour.split(',').map(h => h.trim())
      for (const h of hourValues) {
        const num = parseInt(h)
        if (isNaN(num) || num < 0 || num > 23) {
          errors.value.hour = t('scheduledTasks.form.hourInvalid')
          return false
        }
      }
    }
  }

  // Validate day_of_month, month_of_year, day_of_week if shown
  if (isGithubTrendingTask || formData.value.task_type === 'articlehub.collect_articles') {
    const dayOfMonth = (crontabInput.value.day_of_month || '*').trim()
    const monthOfYear = (crontabInput.value.month_of_year || '*').trim()
    const dayOfWeek = (crontabInput.value.day_of_week || '*').trim()

    // Validate day_of_month (1-31 or *)
    if (dayOfMonth !== '*') {
      const dayValues = dayOfMonth.split(',').map(d => d.trim())
      for (const d of dayValues) {
        const num = parseInt(d)
        if (isNaN(num) || num < 1 || num > 31) {
          errors.value.day_of_month = t('scheduledTasks.form.dayOfMonthInvalid')
          return false
        }
      }
    }

    // Validate month_of_year (1-12 or *)
    if (monthOfYear !== '*') {
      const monthValues = monthOfYear.split(',').map(m => m.trim())
      for (const m of monthValues) {
        const num = parseInt(m)
        if (isNaN(num) || num < 1 || num > 12) {
          errors.value.month_of_year = t('scheduledTasks.form.monthOfYearInvalid')
          return false
        }
      }
    }

    // Validate day_of_week (0-7 or *, where 0 and 7 both mean Sunday)
    if (dayOfWeek !== '*') {
      const weekValues = dayOfWeek.split(',').map(w => w.trim())
      for (const w of weekValues) {
        const num = parseInt(w)
        if (isNaN(num) || num < 0 || num > 7) {
          errors.value.day_of_week = t('scheduledTasks.form.dayOfWeekInvalid')
          return false
        }
      }
    }

    // Update formData with all crontab fields
    formData.value.schedule_value.day_of_month = dayOfMonth
    formData.value.schedule_value.month_of_year = monthOfYear
    formData.value.schedule_value.day_of_week = dayOfWeek
  }

  // Update formData
  formData.value.schedule_value.minute = minute === '*' ? '*' : minute
  formData.value.schedule_value.hour = hour

  return true
}

watch([() => crontabInput.value.minute, () => crontabInput.value.hour], () => {
  validateCrontab()
})

const handleSearchTypeChange = () => {
  // Clear the other type when switching
  if (searchType.value === 'keywords') {
    selectedTopic.value = ''
    formData.value.kwargs.topics = []
    // Ensure at least one input box exists
    if (keywordInputs.value.length === 0) {
      keywordInputs.value = ['']
    }
  } else {
    keywordInputs.value = ['']
    formData.value.kwargs.keywords = []
    errors.value.keywords = ''
    // Clear individual keyword errors
    Object.keys(errors.value).forEach(key => {
      if (key.startsWith('keyword_')) {
        delete errors.value[key]
      }
    })
  }
}

const addKeywordInput = () => {
  if (keywordInputs.value.length < 4) {
    keywordInputs.value.push('')
  }
}

const removeKeywordInput = (index) => {
  if (keywordInputs.value.length > 1) {
    keywordInputs.value.splice(index, 1)
    delete errors.value[`keyword_${index}`]
    // Re-index errors for remaining inputs
    const newErrors = {}
    Object.keys(errors.value).forEach(key => {
      if (key.startsWith('keyword_')) {
        const oldIndex = parseInt(key.split('_')[1])
        if (oldIndex > index) {
          newErrors[`keyword_${oldIndex - 1}`] = errors.value[key]
        } else if (oldIndex < index) {
          newErrors[key] = errors.value[key]
        }
      } else {
        newErrors[key] = errors.value[key]
      }
    })
    errors.value = newErrors
    updateKeywords()
  }
}

const handleKeywordInput = (index) => {
  // Clear error for this keyword
  delete errors.value[`keyword_${index}`]
  updateKeywords()
}

const validateKeyword = (index) => {
  const keyword = keywordInputs.value[index]?.trim() || ''
  const maxLength = 20

  if (keyword && keyword.length > maxLength) {
    errors.value[`keyword_${index}`] = t('scheduledTasks.form.keywordTooLong', { max: maxLength })
    return false
  }

  // Check for duplicates
  const trimmedKeyword = keyword.toLowerCase()
  const duplicates = keywordInputs.value.filter((k, i) =>
    i !== index && k.trim().toLowerCase() === trimmedKeyword && trimmedKeyword !== ''
  )

  if (duplicates.length > 0) {
    errors.value[`keyword_${index}`] = t('scheduledTasks.form.keywordDuplicate')
    return false
  }

  delete errors.value[`keyword_${index}`]
  updateKeywords()
  return true
}

const updateKeywords = () => {
  // Get all non-empty keywords
  const keywords = keywordInputs.value
    .map(k => k.trim())
    .filter(k => k)

  // Validate each keyword
  const maxLength = 20
  let hasError = false

  keywordInputs.value.forEach((keyword, index) => {
    const trimmed = keyword.trim()
    if (trimmed && trimmed.length > maxLength) {
      errors.value[`keyword_${index}`] = t('scheduledTasks.form.keywordTooLong', { max: maxLength })
      hasError = true
    }
  })

  // Check for duplicates
  keywordInputs.value.forEach((keyword, index) => {
    const trimmed = keyword.trim().toLowerCase()
    if (trimmed) {
      const duplicates = keywordInputs.value.filter((k, i) =>
        i !== index && k.trim().toLowerCase() === trimmed
      )
      if (duplicates.length > 0) {
        errors.value[`keyword_${index}`] = t('scheduledTasks.form.keywordDuplicate')
        hasError = true
      }
    }
  })

  if (!hasError) {
    if (keywords.length === 0) {
      errors.value.keywords = t('scheduledTasks.form.atLeastOneKeyword')
    } else {
      delete errors.value.keywords
    }
  }

  // Update formData
  formData.value.kwargs.keywords = keywords
}

const handleTopicChange = () => {
  updateTopics()
}

const updateTopics = () => {
  // Single topic selection
  if (selectedTopic.value) {
    formData.value.kwargs.topics = [selectedTopic.value]
  } else {
    formData.value.kwargs.topics = []
  }
}

const resetForm = () => {
  const currentMinute = String(new Date().getMinutes())
  const defaultData = {
    ...DEFAULT_FORM_DATA,
    schedule_value: {
      minute: currentMinute,
      hour: '*',
      day_of_month: '*',
      month_of_year: '*',
      day_of_week: '*'
    },
    start_time: getCurrentDateTime()
  }
  formData.value = defaultData
  crontabInput.value = {
    minute: currentMinute,
    hour: '*',
    day_of_month: '*',
    month_of_year: '*',
    day_of_week: '*'
  }
  keywordInputs.value = ['']
  selectedTopic.value = ''
  searchType.value = 'keywords'
  formData.value.kwargs.transform_formats = ['markdown_json', 'toutiao']
  errors.value = {}

  // Reset previous auto name and set initial value
  previousAutoName.value = ''
  // Use nextTick to ensure formData is updated before computing autoGeneratedName
  setTimeout(() => {
    if (autoGeneratedName.value) {
      formData.value.name = autoGeneratedName.value
      previousAutoName.value = autoGeneratedName.value
    }
  }, 0)
}

const loadTask = async () => {
  if (props.task) {
    // If task has UUID but no kwargs, fetch full task data
    let taskData = props.task
    if (props.task.uuid && (!props.task.kwargs || Object.keys(props.task.kwargs || {}).length === 0)) {
      try {
        const response = await scheduledTasksApi.getScheduledTask(props.task.uuid)
        const fullTaskData = extractResponseData(response)
        if (fullTaskData) {
          taskData = fullTaskData
        }
      } catch (error) {
        // Continue with existing task data
      }
    }

    const kwargs = taskData.kwargs || {}

    // Handle legacy field names (language -> source_language, region -> source_region)
    const sourceLanguage = kwargs.source_language || kwargs.language || 'en'
    const sourceRegion = kwargs.source_region || kwargs.region || 'US'

    // Parse schedule_value for crontab
    // Handle old format tasks that may be missing minute/hour fields
    const currentMinute = String(new Date().getMinutes())
    let minuteValue = currentMinute
    let hourValue = '*'
    let scheduleValue = {}

    if (taskData.schedule_type === 'crontab' && taskData.schedule_value) {
      scheduleValue = { ...taskData.schedule_value }
      // Extract minute and hour values for crontab input
      // Use defaults if fields are missing (old format)
      if (scheduleValue.minute !== undefined && scheduleValue.minute !== null) {
        minuteValue = String(scheduleValue.minute)
      }
      if (scheduleValue.hour !== undefined && scheduleValue.hour !== null) {
        hourValue = String(scheduleValue.hour)
      }
    } else {
      // Convert interval to crontab (default values)
      scheduleValue = {}
    }

    // Set crontab input values
    // Use task's timezone if available, otherwise use browser timezone
    const taskTimezone = scheduleValue.timezone || currentTimezone.value

    crontabInput.value = {
      minute: minuteValue,
      hour: hourValue,
      day_of_month: scheduleValue.day_of_month || '*',
      month_of_year: scheduleValue.month_of_year || '*',
      day_of_week: scheduleValue.day_of_week || '*'
    }

    formData.value = {
      name: taskData.name || '',
      task_type: taskData.task_type || TASK_TYPE,
      schedule_type: 'crontab',
      schedule_value: {
        minute: minuteValue,
        hour: hourValue,
        day_of_month: scheduleValue.day_of_month || '*',
        month_of_year: scheduleValue.month_of_year || '*',
        day_of_week: scheduleValue.day_of_week || '*',
        timezone: taskTimezone
      },
      start_time: taskData.start_time ? formatDateTimeForInput(taskData.start_time) : getCurrentDateTime(),
      kwargs: {
        keywords: kwargs.keywords || [],
        topics: kwargs.topics || [],
        count: kwargs.count !== undefined ? kwargs.count : 10,
        source_language: sourceLanguage,
        source_region: sourceRegion,
        period: kwargs.period || '7d',
        social_account: kwargs.social_account || '',
        transform_formats: kwargs.transform_formats || ['markdown_json', 'toutiao'],
        lang_code: kwargs.lang_code || 'any',
        lang: kwargs.lang || 'any',
        since: kwargs.since || 'today',
        num: kwargs.num !== undefined ? kwargs.num : 20
      },
      enabled: taskData.enabled !== undefined ? taskData.enabled : true
    }

    // Set previousAutoName for editing tasks
    // This allows us to detect if the name should be auto-updated
    if (formData.value.name) {
      previousAutoName.value = formData.value.name
    } else if (autoGeneratedName.value) {
      previousAutoName.value = autoGeneratedName.value
    }

    // Determine search type based on existing data
    if (formData.value.kwargs.keywords && formData.value.kwargs.keywords.length > 0) {
      // Load keywords
      searchType.value = 'keywords'
      const keywords = Array.isArray(formData.value.kwargs.keywords)
        ? formData.value.kwargs.keywords
        : [formData.value.kwargs.keywords]

      // Fill keyword inputs (max 4, pad with empty strings if needed)
      // Use nextTick to avoid triggering watch during load
      setTimeout(() => {
        keywordInputs.value = keywords.slice(0, 4).map(k => k || '')
        if (keywordInputs.value.length === 0) {
          keywordInputs.value = ['']
        }
      }, 0)

      // Clear topic
      selectedTopic.value = ''
    } else if (formData.value.kwargs.topics && formData.value.kwargs.topics.length > 0) {
      // Load topic
      searchType.value = 'topics'
      const topics = Array.isArray(formData.value.kwargs.topics)
        ? formData.value.kwargs.topics
        : [formData.value.kwargs.topics]

      // Set first topic (single selection)
      selectedTopic.value = topics.length > 0 && availableTopics.includes(topics[0]) ? topics[0] : ''

      // Clear keywords
      keywordInputs.value = ['']
    } else {
      // Default to keywords
      searchType.value = 'keywords'
      keywordInputs.value = ['']
      selectedTopic.value = ''
    }


  } else {
    resetForm()
  }
}

watch(() => props.show, async (show) => {
  if (show) {
    // Always load task types first
    await loadTaskTypes()

    // Then load task data if editing, or reset form if creating new
    if (props.task) {
      loadTask()
    } else {
      resetForm()
    }
  } else {
    // Reset saving state when modal closes
    saving.value = false
  }
}, { immediate: false })

// Also watch for task changes
watch(() => props.task, (task) => {
  if (props.show && task) {
    loadTask()
  }
}, { immediate: false })

onMounted(() => {
  loadTaskTypes()
})

// Watch selectedTopic to update formData.kwargs.topics
watch(selectedTopic, () => {
  if (!props.task) {
    updateTopics()
  }
})

// Watch keywordInputs to update formData.kwargs.keywords
// Only for new tasks, not when editing
watch(keywordInputs, () => {
  if (!props.task && searchType.value === 'keywords') {
    updateKeywords()
  }
}, { deep: true, flush: 'post' })

// Watch for changes to update formData.name from autoGeneratedName
// This ensures formData.name is synced with the computed autoGeneratedName
// Only for new tasks, not when editing
watch(
  () => autoGeneratedName.value,
  (newName) => {
    if (!props.task && newName) {
      // Always update name if it's empty or if it matches the previous auto-generated name
      // This allows auto-update when parameters change
      if (!formData.value.name || formData.value.name === previousAutoName.value) {
        formData.value.name = newName
        previousAutoName.value = newName
      }
    }
  },
  { immediate: false }
)

// Track previous auto-generated name to detect if current name is auto-generated
const previousAutoName = ref('')

// Watch task type changes to trigger name regeneration
watch(
  () => formData.value.task_type,
  () => {
    if (!props.task) {
      generateTaskName()
      if (autoGeneratedName.value) {
        previousAutoName.value = autoGeneratedName.value
      }
    }
  }
)

// Watch GitHub trending parameters to update name automatically
watch(
  () => [
    formData.value.kwargs?.since,
    formData.value.kwargs?.lang,
    formData.value.kwargs?.lang_code
  ],
  () => {
    if (formData.value.task_type === 'github_trending.collect_github_trendings') {
      // For new tasks, always update name when parameters change
      // For existing tasks, update name if it matches previous auto-generated name
      // or if name is empty
      if (!props.task) {
        // New task: always update
        if (autoGeneratedName.value) {
          formData.value.name = autoGeneratedName.value
          previousAutoName.value = autoGeneratedName.value
        }
      } else {
        // Existing task: update if name matches previous auto-generated name
        // This allows auto-update when editing parameters
        if (!formData.value.name || formData.value.name === previousAutoName.value) {
          if (autoGeneratedName.value) {
            formData.value.name = autoGeneratedName.value
            previousAutoName.value = autoGeneratedName.value
          }
        }
      }
    }
  },
  { deep: true }
)

// Watch Google News parameters to update name automatically
watch(
  () => [
    formData.value.kwargs?.keywords,
    formData.value.kwargs?.topics,
    formData.value.kwargs?.social_account,
    keywordInputs.value,
    selectedTopic.value
  ],
  () => {
    if (formData.value.task_type === 'articlehub.collect_articles') {
      // For new tasks, always update name when parameters change
      // For existing tasks, update name if it matches previous auto-generated name
      // or if name is empty
      if (!props.task) {
        // New task: always update
        if (autoGeneratedName.value) {
          formData.value.name = autoGeneratedName.value
          previousAutoName.value = autoGeneratedName.value
        }
      } else {
        // Existing task: update if name matches previous auto-generated name
        // This allows auto-update when editing parameters
        if (!formData.value.name || formData.value.name === previousAutoName.value) {
          if (autoGeneratedName.value) {
            formData.value.name = autoGeneratedName.value
            previousAutoName.value = autoGeneratedName.value
          }
        }
      }
    }
  },
  { deep: true }
)

const validate = () => {
  errors.value = {}

  // Validate task type
  if (!formData.value.task_type || !formData.value.task_type.trim()) {
    errors.value.task_type = t('scheduledTasks.form.taskTypeRequired')
  }

  // Validate collection task fields
  // Skip validation for GitHub trending tasks (they have different fields)
  if (formData.value.task_type === 'github_trending.collect_github_trendings') {
    // GitHub trending tasks don't need keywords/topics validation
    // They use lang_code, lang, since, num instead
  } else if (searchType.value === 'keywords') {
    // Validate keywords
    updateKeywords() // This will set errors.keywords if needed
    const hasKeywords = keywordInputs.value.some(k => k.trim())
    if (!hasKeywords) {
      errors.value.keywords = t('scheduledTasks.form.atLeastOneKeyword')
    }
    // Clear topic errors (delete instead of setting to empty string)
    delete errors.value.topics
  } else if (searchType.value === 'topics') {
    // Validate topic
    if (!selectedTopic.value) {
      errors.value.topics = t('scheduledTasks.form.topicRequired')
    } else {
      delete errors.value.topics
    }
    // Clear keyword errors (delete instead of setting to empty string)
    delete errors.value.keywords
  } else {
    // No search type selected
    errors.value.keywords = t('scheduledTasks.form.searchTypeRequired')
    errors.value.topics = t('scheduledTasks.form.searchTypeRequired')
  }

  // Validate social_account
  if (!formData.value.kwargs.social_account || !formData.value.kwargs.social_account.trim()) {
    errors.value.social_account = t('scheduledTasks.form.socialAccountRequired')
  }

  // Validate transform_formats
  if (!formData.value.kwargs.transform_formats || formData.value.kwargs.transform_formats.length === 0) {
    errors.value.transform_formats = t('scheduledTasks.form.transformFormatsRequired')
  }

  // Validate crontab settings
  if (!validateCrontab()) {
    return false
  }

  // Ensure name is set from autoGeneratedName (only for new tasks)
  if (!props.task && autoGeneratedName.value) {
    formData.value.name = autoGeneratedName.value
    previousAutoName.value = autoGeneratedName.value
  }

  return Object.keys(errors.value).length === 0
}

const handleSubmit = () => {
  // Update form data before validation
  if (formData.value.task_type === 'github_trending.collect_github_trendings') {
    // GitHub trending tasks don't need keywords/topics update
  } else if (searchType.value === 'keywords') {
    updateKeywords()
    formData.value.kwargs.topics = []
  } else if (searchType.value === 'topics') {
    updateTopics()
    formData.value.kwargs.keywords = []
  }

  // Validate form
  if (!validate()) {
    // Scroll to first error
    const firstErrorElement = document.querySelector('.border-red-500, .text-red-600')
    if (firstErrorElement) {
      firstErrorElement.scrollIntoView({ behavior: 'smooth', block: 'center' })
    }
    return
  }

  const submitData = { ...formData.value }

  submitData.schedule_type = 'crontab'
  const minuteValue = crontabInput.value.minute.trim()
  const hourValue = crontabInput.value.hour.trim()

  // Get day_of_month, month_of_year, day_of_week from formData.schedule_value
  // (set by validateCrontab) or from crontabInput, or default to '*'
  const dayOfMonth = formData.value.schedule_value?.day_of_month
    || crontabInput.value.day_of_month?.trim()
    || '*'
  const monthOfYear = formData.value.schedule_value?.month_of_year
    || crontabInput.value.month_of_year?.trim()
    || '*'
  const dayOfWeek = formData.value.schedule_value?.day_of_week
    || crontabInput.value.day_of_week?.trim()
    || '*'

  submitData.schedule_value = {
    minute: minuteValue,
    hour: hourValue,
    day_of_month: dayOfMonth,
    month_of_year: monthOfYear,
    day_of_week: dayOfWeek,
    timezone: currentTimezone.value
  }

  // Ensure name is set
  // For GitHub trending tasks, update name if it matches previous auto-generated name
  // or if name is empty (to reflect current parameters)
  if (submitData.task_type === 'github_trending.collect_github_trendings') {
    if (!submitData.name || !submitData.name.trim() ||
        submitData.name === previousAutoName.value) {
      if (autoGeneratedName.value) {
        submitData.name = autoGeneratedName.value
      }
    }
  } else if (submitData.task_type === 'articlehub.collect_articles') {
    // For Google News tasks, update name if it matches previous auto-generated name
    // or if name is empty (to reflect current parameters)
    if (!submitData.name || !submitData.name.trim() ||
        submitData.name === previousAutoName.value) {
      if (autoGeneratedName.value) {
        submitData.name = autoGeneratedName.value
      }
    }
  } else if (!submitData.name || !submitData.name.trim()) {
    // For other task types, use auto-generated name if available
    if (autoGeneratedName.value) {
      submitData.name = autoGeneratedName.value
    } else if (props.task && props.task.name) {
      submitData.name = props.task.name
    } else {
      // Fallback: generate a basic name
      submitData.name = `Task_${Date.now()}`
    }
  }

  // Ensure start_time is set and convert to UTC ISO format
  if (!submitData.start_time) {
    submitData.start_time = new Date().toISOString()
  } else {
    // Convert local datetime string to UTC ISO format
    // If it's already in ISO format, parse and ensure it's UTC
    try {
      const dateObj = new Date(submitData.start_time)
      if (!isNaN(dateObj.getTime())) {
        submitData.start_time = dateObj.toISOString()
      }
    } catch (error) {
      // If parsing fails, use current time in UTC
      submitData.start_time = new Date().toISOString()
    }
  }

  // Clean up the data - remove undefined/null values and ensure proper format
  // Remove read-only fields that shouldn't be sent in update
  if (props.task) {
    delete submitData.uuid
    delete submitData.created_at
    delete submitData.updated_at
  }

  // Ensure kwargs is properly formatted
  if (!submitData.kwargs) {
    submitData.kwargs = {}
  }

  // Ensure keywords and topics are arrays
  if (submitData.kwargs.keywords && !Array.isArray(submitData.kwargs.keywords)) {
    submitData.kwargs.keywords = []
  }
  if (submitData.kwargs.topics && !Array.isArray(submitData.kwargs.topics)) {
    submitData.kwargs.topics = []
  }
  // Ensure transform_formats is an array
  if (!submitData.kwargs.transform_formats || !Array.isArray(submitData.kwargs.transform_formats)) {
    submitData.kwargs.transform_formats = ['markdown_json', 'toutiao']
  }

  // Ensure args is an array (if not set)
  if (!submitData.args) {
    submitData.args = []
  } else if (!Array.isArray(submitData.args)) {
    submitData.args = []
  }

  saving.value = true
  emit('save', submitData)

  // Reset saving state after a delay if modal is still open
  // This handles cases where save fails and modal doesn't close
  setTimeout(() => {
    if (props.show && saving.value) {
      saving.value = false
    }
  }, 5000)
}

const handleClose = () => {
  emit('close')
}
</script>

<style scoped>
@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fade-in {
  animation: fade-in 0.2s ease-out;
}
</style>
